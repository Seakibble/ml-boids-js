<html>

    <body>
        <style>
            * {
                margin: 0;
                padding: 0;
            }

            #container {
                width: 100vw;
                height: 100vh;
                background: #000;
            }

            #canvas {
                background: #333;
            }

        </style>

        <div id="container">
            <canvas id="canvas"></canvas>
        </div>

        <script>
            ////// INITIALIZE
            Vector = function (_x, _y) {
                return {
                    x: _x,
                    y: _y,
                    Add: function (_vec) {
                        this.x += _vec.x;
                        this.y += _vec.y;
                    },
                    Subtract: function (_vec) {
                        this.x -= _vec.x;
                        this.y -= _vec.y;
                    },
                    Diff: function (_vec) {
                        return Vector(this.x - _vec.x, this.y - _vec.y);
                    },
                    Set: function (_x, _y) {
                        this.x = _x;
                        this.y = _y;
                    },
                    Mult: function (_n) {
                        this.x *= _n;
                        this.y *= _n;
                    },
                    Dist: function (_vec) {
                        var diff = this.Diff(_vec);
                        return Math.sqrt(diff.x * diff.x + diff.y * diff.y);
                    },
                    Normalize: function (_n) {
                        var d = this.Dist(Vector(0, 0));
                        return this.Mult(_n / d);
                    },
                    Report: function () {
                        console.log(this.x + ", " + this.y);
                    }
                }
            };

            function Screenwrap(_vec) {
                if (_vec.x > canvas.width) {
                    _vec.x -= canvas.width;
                }
                if (_vec.x < 0) {
                    _vec.x += canvas.width;
                }
                if (_vec.y > canvas.height) {
                    _vec.y -= canvas.height;
                }
                if (_vec.y < 0) {
                    _vec.y += canvas.height;
                }
                return _vec;
            }

            Boid = function (_id, _x, _y, _sprite, _master) {
                return {
                    id: _id,
                    pos: Vector(_x, _y),
                    velocity: Vector(0, 0),
                    config: {
                        maxSpeed: Math.random() + 1,
                        baseWeight: Math.round((Math.random() * 5) * 10) / 10 + 6,
                        alignment: {
                            range: 100,
                            weight: Math.round((Math.random()) * 10) / 10,
                        },
                        cohesion: {
                            range: 100,
                            weight: Math.round((Math.random()) * 10) / 10,
                        },
                        separation: {
                            range: 100,
                            weight: Math.round((Math.random()) * 10) / 10,
                        }
                    },
                    master: _master,
                    SetVelocity: function (vec) {
                        this.velocity = vec;
                    },
                    SetPos: function (vec) {
                        this.pos = vec;
                    },
                    Draw: function () {
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.fillStyle = 'rgb('
                            + (this.config.alignment.weight * 150 + 100) + ','
                            + (this.config.cohesion.weight * 150 + 100) + ','
                            + (this.config.separation.weight * 150 + 100) + ')';

                        ctx.beginPath();
                        ctx.arc(this.pos.x, this.pos.y, (this.config.baseWeight - 5) / 5 * 6, 0, Math.PI * 2, true);
                        ctx.fill();
                    },
                    Update: function () {
                        // Apply weight of initial velocity
                        this.velocity.Mult(this.config.baseWeight);

                        // Setup rule variables
                        var alignment = { vec: Vector(0, 0), agentCount: 0 };
                        var cohesion = { vec: Vector(0, 0), agentCount: 0 };
                        var separation = { vec: Vector(0, 0), agentCount: 0 };

                        // Collect rule vectors
                        for (var i = 0; i < this.master.length; i++) {
                            if (this.id !== i) {
                                // Get the relative distance of the other agent from this agent
                                var centerOffset = center.Diff(this.pos);
                                var agentPos = Vector(this.master[i].pos.x, this.master[i].pos.y);
                                agentPos.Add(centerOffset);
                                agentPos = Screenwrap(agentPos);
                                var dist = this.pos.Dist(agentPos);

                                if (dist < this.config.alignment.range && dist > 1) {
                                    alignment.agentCount++;
                                    alignment.vec.Add(this.master[i].velocity);
                                }

                                if (dist < this.config.cohesion.range && dist > 1) {
                                    cohesion.agentCount++;
                                    cohesion.vec.Add(agentPos);
                                }

                                if (dist < this.config.separation.range && dist > 1) {
                                    separation.agentCount++;
                                    separation.vec.Add(agentPos.Diff(this.pos));
                                }
                            }
                        }

                        // Normalize vectors, apply weights then add to velocity
                        if (alignment.agentCount > 0) {
                            alignment.vec.Mult(1 / alignment.agentCount);
                            alignment.vec.Normalize(this.config.maxSpeed);

                            alignment.vec.Mult(this.config.alignment.weight);
                            this.velocity.Add(alignment.vec);
                        }

                        if (cohesion.agentCount > 0) {
                            cohesion.vec.Mult(1 / cohesion.agentCount);
                            cohesion.vec = cohesion.vec.Diff(this.pos);
                            cohesion.vec.Normalize(this.config.maxSpeed);

                            cohesion.vec.Mult(this.config.cohesion.weight);
                            this.velocity.Add(cohesion.vec);
                        }

                        if (separation.agentCount > 0) {
                            separation.vec.Mult(1 / separation.agentCount);
                            separation.vec.Normalize(-this.config.maxSpeed);

                            separation.vec.Mult(this.config.separation.weight);
                            this.velocity.Add(separation.vec);
                        }

                        // Normalize for final velocity, then apply
                        this.velocity.Normalize(this.config.maxSpeed);
                        this.pos.Add(this.velocity);

                        // Wrap to other side of the environment if out of frame.
                        this.pos = Screenwrap(this.pos);
                    }
                }
            };

            // Resize the canvas to match its container size
            function resizeCanvas() {
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
                center = Vector(canvas.width / 2, canvas.height / 2);
            }

            var container = document.getElementById('container');
            var canvas = document.getElementById('canvas');
            var ctx = canvas.getContext('2d');
            var center = null;

            // Set the canvas size, and add the listener so it resizes properly later
            resizeCanvas()
            window.addEventListener('resize', resizeCanvas);




            var boids = [];
            var boidsCount = 100;
            for (var i = 0; i < boidsCount; i++) {
                boids[i] = Boid(i, Math.random() * canvas.width, Math.random() * canvas.height, boidSprite, boids);
                boids[i].SetVelocity(Vector(Math.random() * 4 - 2, Math.random() * 4 - 2));
            }

            ////////////////////////////////////////////////////////////////////////////////////

            function init() {
                window.requestAnimationFrame(draw);
            }

            function draw() {
                ////// UPDATE
                for (var i = 0; i < boidsCount; i++) {
                    boids[i].Update();
                }

                ////// RENDER

                // Clear
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw Boids
                for (var i = 0; i < boidsCount; i++) {
                    boids[i].Draw();
                }

                // Earth
                //        var time = new Date();
                //        ctx.rotate(((2 * Math.PI) / 60) * time.getSeconds() + ((2 * Math.PI) / 60000) * time.getMilliseconds());
                //        ctx.translate(105, 0);
                //        ctx.fillRect(0, -12, 50, 24); // Shadow
                //        ctx.drawImage(earth, -12, -12);

                // Moon
                //        ctx.save();
                //        ctx.rotate((((2 * Math.PI) / 6) * time.getSeconds() + ((2 * Math.PI) / 6000) * time.getMilliseconds())* 8);
                //        ctx.translate(0, 5);
                //        ctx.drawImage(ball, -3.5, -3.5);
                //        ctx.restore();



                //        ctx.beginPath();
                //        ctx.arc(150, 150, 105, 0, Math.PI * 2, false); // Earth orbit
                //        ctx.stroke();

                //        ctx.drawImage(sun, 0, 0, 300, 300);

                window.requestAnimationFrame(draw);
            }

            init();

        </script>
    </body>

</html>
